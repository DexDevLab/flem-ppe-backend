<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    
    
    <meta name="author" content="https://github.com/DexDevLab" />
    
    <meta name="author" content="https://github.com/rodsl" />
    
    <meta name="description" content="Aplicação Backend para o Portal Programa Primeiro Emprego, da FLEM" />
    
    

    <!-- Adding external script-->
    
    
    <script src="https://code.jquery.com/jquery-3.5.1.js" integrity="sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=" crossorigin="anonymous" ></script>
    
    

    <!-- Adding external style-->
    
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous" />
    
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/overlayscrollbars/1.13.0/js/OverlayScrollbars.min.js"
      integrity="sha512-5R3ngaUdvyhXkQkIqTf/k+Noq3phjmrqlUQyQYbgfI34Mzcx7vLIIYTy/K1VMHkL33T709kfh5y6R9Xy/Cbt7Q=="
      crossorigin="anonymous"></script>
    

    <!-- Adding overlay style-->
    


    <title>
      controller/eventos/index.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">FLEM PPE Backend - Documentação</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><ul><li class="menu-li"><a href='https://frtechnologies.com.br' class='some-class menu-link' id='some-id' target='_blank'>Website</a></li><li class="menu-li"><a href='https://github.com/frtechdev/flem-ppe-backend/' class='some-class menu-link' id='some-id' target='_blank'>Github</a></li></ul><div class="accordion collapsed" id="3739838" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#benefCheckBd">benefCheckBd</a></li><li class="accordion-list" id=""><a href="global.html#benefValidate">benefValidate</a></li><li class="accordion-list" id=""><a href="global.html#modifyContatoAcaoCr">modifyContatoAcaoCr</a></li><li class="accordion-list" id=""><a href="global.html#modifyEscRegMunicMonit">modifyEscRegMunicMonit</a></li><li class="accordion-list" id=""><a href="global.html#normalizeString">normalizeString</a></li><li class="accordion-list" id=""><a href="global.html#parseArrayToString">parseArrayToString</a></li><li class="accordion-list" id=""><a href="global.html#parseArrayToStringEquals">parseArrayToStringEquals</a></li><li class="accordion-list" id=""><a href="global.html#queryComposer">queryComposer</a></li><li class="accordion-list" id=""><a href="global.html#replaceKeys">replaceKeys</a></li></ul> </div>
      
        <div class="navbar-resize" id="navbar-resize">
          <div class="resize-dots-container">
            <div class="dots"></div>
            <div class="dots"></div>
            <div class="dots"></div>
          </div> 
        </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        controller/eventos/index.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { getBeneficiarios } from "controller/beneficiarios";
import { getTiposHistorico } from "controller/historicos";
import _ from "lodash";
import { DateTime } from "luxon";
import { prisma } from "services";
import { queryComposer } from "services/prisma/queryComposer";
import { exceptionHandler } from "utils/exceptionHandler";

/**
 * Fornece a listagem de Eventos.
 * @method getEventos
 * @memberof module:eventos
 * @param {String} entity a localidade do Projeto (por exemplo, "ba" para Bahia)
 * @param {Object} filter Critério de pesquisa para detalhamento da query, onde os
 * critérios de pesquisa aceitos são os parâmetros possíveis no método queryComposer.
 * @param {Number} limit limita a quantidade de resultados na pesquisa. Por questões
 * de performance, em queries longas é sugerido usar limit como '1' quando se deseja
 * obter apenas 1 (ou o primeiro) resultado.
 * @returns {Object} Objeto contendo um Array de resultados. Ao usar 'limit',
 * selecionar o índice zero no objeto ([0]) para obter o valor adequado.
 */
export function getEventos(entity, filter, limit) {
  try {
    const table = `${entity}_Eventos`;
    if (!_.isEmpty(filter)) {
      return prisma[table].findMany({
        orderBy: [
          {
            nome: "asc",
          },
        ],
        take: _.isUndefined(limit) ? undefined : parseInt(limit),
        where: {
          ...queryComposer(filter),
        },
        include: {
          localEvento: true,
          tipoEvento: true,
          benefAssoc: true,
          acao_Cr: {
            include: {
              colabCr: true,
            },
          },
          comunicado: true,
        },
      });
    } else {
      return prisma[table].findMany({
        orderBy: [
          {
            nome: "asc",
          },
        ],
        take: _.isUndefined(limit) ? undefined : parseInt(limit),
        where: {
          excluido: {
            equals: false,
          },
        },
        include: {
          localEvento: true,
          tipoEvento: true,
          benefAssoc: true,
          acao_Cr: {
            include: {
              colabCr: true,
            },
          },
          comunicado: true,
        },
      });
    }
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}

/**
 * Adiciona um novo Evento à lista de Eventos.
 * @method addEvento
 * @memberof module:eventos
 * @param {String} entity a localidade do Projeto (por exemplo, "ba" para Bahia)
 * @param {Object} dadosEvento detalhes do Evento, necessários
 * para sua inclusão:
 *
 * nome - nome do evento
 *
 * modalidade - modalidade do evento (se presencial ou remoto)
 *
 * data - data do evento
 *
 * local - local do evento
 *
 * tipo - tipo de evento
 *
 * benefAssoc - lista de beneficiários associados/convidados para o evento
 *
 * criarAcaoCR - booleano se deve ser criada uma Ação à CR para o evento
 *
 * colabAcaoCR - colaboradores da CR que atuarão na Ação CR
 *
 * emailAlerts - booleano se deve haver envio de email sobre o evento
 *
 * emailRemetente - remetente do email
 *
 * conteudoEmail - texto de conteúdo do email
 *
 * @returns {Object} Objeto contendo um Array de resultados.
 */
export async function addEvento(entity, dadosEvento) {
  try {
    const {
      nome,
      modalidade,
      data,
      local,
      tipo,
      benefAssoc,
      criarAcaoCR,
      colabAcaoCR,
      emailAlerts,
      emailRemetente,
      conteudoEmail = null,
    } = dadosEvento;

    const benefMatriculas = benefAssoc
      .filter(({ value }) => value)
      .map((benef) => parseInt(benef.value));
    const benefCPFs = benefAssoc
      .filter(({ value }) => value)
      .map((benef) => benef.value.toString());
    const parsedConteudoEmail = JSON.stringify(conteudoEmail);

    const table = `${entity}_Eventos`;

    const benefToConnectAcao = await getBeneficiarios(entity, {
      cpf: benefCPFs,
      matriculaFlem: benefMatriculas,
      condition: "OR",
    });

    const query = await prisma[table].create({
      data: {
        nome,
        modalidade,
        data: DateTime.fromISO(data).toISO(),
        local_EventoId: local,
        tipo_eventoId: tipo,
        benefAssoc: {
          connect: benefToConnectAcao.map(({ id }) => ({ id })),
        },
        acao_Cr: criarAcaoCR
          ? {
              create: {
                nome,
                descricao:
                  "Ação gerada automaticamente na criação do evento " + nome,
                benefAssoc: {
                  connect: benefToConnectAcao.map(({ id }) => ({ id })),
                },
                colabCr: {
                  connect: colabAcaoCR.map(({ value }) => ({ id: value })),
                },
              },
            }
          : {},
        comunicado: emailAlerts
          ? {
              create: {
                assunto: `PPE - Novo Evento: ${nome}`,
                conteudoEmail: parsedConteudoEmail,
                remetenteComunicado: {
                  connect: {
                    id: emailRemetente,
                  },
                },
                benefAssoc: {
                  connect: benefToConnectAcao.map(({ id }) => ({ id })),
                },
              },
            }
          : {},
      },
      include: {
        acao_Cr: true,
        comunicado: true,
      },
    });
    return query;
  } catch (e) {
    throw exceptionHandler(e);
  }
}

/**
 * Altera dados de Evento de um Evento no BD.
 * @method modifyEvento
 * @memberof module:eventos
 * @param {String} entity a "entidade" ou "localização" do Projeto Primeiro Emprego
 * @param {Object} dadosEvento detalhes e informações adicionais sobre o Evento:
 *
 * id - o ID do Evento a ser alterado
 *
 * nome - Nome do Evento
 *
 * modalidade - Se o Evento é presencial ou remoto
 *
 * data - A data do Evento
 *
 * local - O local do Evento
 *
 * tipo - O Tipo de Evento (Seminário de Acolhimento, Oficina, Seminário etc)
 *
 * benefAssoc - Listagem de Beneficiários associados a este Evento
 *
 * acao_CrId - O ID da Ação relacionada a esse Evento
 *
 * criarAcaoCR - Se TRUE, cria uma Ação para a Central de Relacionamento, contendo
 * os dados pertinentes ao Evento
 *
 * colabAcaoCR - Colaboradores vinculados à Ação criada para atender ao Evento
 *
 * @returns {Object} Objeto contendo um Array de resultados.
 */
export async function modifyEvento(entity, dadosEvento) {
  const {
    id,
    nome,
    modalidade,
    data,
    local,
    tipo,
    benefAssoc,
    acao_CrId,
    criarAcaoCR,
    colabAcaoCR = [],
    emailAlerts,
    comunicado_Id,
    emailRemetente,
    conteudoEmail = null,
  } = dadosEvento;

  const benefMatriculas = benefAssoc.map((benef) => parseInt(benef.value));
  const benefCPFs = benefAssoc.map((benef) => benef.cpf?.toString());
  const colabMatriculas = colabAcaoCR.map((colab) => colab.value);

  try {
    const table = `${entity}_Eventos`;
    const tableAcoesCr = `${entity}_Acoes_Cr`;
    const tableComunicados = `${entity}_Comunicados`;

    const benefToConnectAcao = await getBeneficiarios(entity, {
      cpf: benefCPFs,
      matriculaFlem: benefMatriculas,
      condition: "OR",
    });

    const getAcaoCr = async () => {
      if (criarAcaoCR) {
        return await prisma[tableAcoesCr].upsert({
          where: {
            id: acao_CrId === undefined ? "" : acao_CrId,
          },
          update: {
            nome,
            descricao:
              "Ação gerada automaticamente na modificação do evento " + nome,
            benefAssoc: {
              set: benefToConnectAcao.map(({ id }) => ({ id })),
            },
            colabCr: {
              set: colabMatriculas.map((value) => ({ id: value })),
            },
            historico: {
              create: {
                // categoria: "Ação CR",
                descricao:
                  "Atualização de ação em função da modificação do evento: " +
                  nome,
                beneficiario: {
                  connect: benefToConnectAcao.map(({ id }) => ({ id })),
                },
                tipoHistorico_Id: (
                  await getTiposHistorico(entity, { nome: "Ação CR" }, 1)
                )[0].id,
              },
            },
            excluido: false,
          },
          create: {
            nome,
            descricao:
              "Ação gerada automaticamente na modificação do evento " + nome,
            benefAssoc: {
              connect: benefToConnectAcao.map(({ id }) => ({ id })),
            },
            colabCr: {
              connect: colabMatriculas.map((value) => ({
                id: value,
              })),
            },
            historico: {
              create: {
                // categoria: "Ação CR",
                descricao:
                  "Criação de ação em função da modificação do evento: " + nome,
                beneficiario: {
                  connect: benefToConnectAcao.map(({ id }) => ({ id })),
                },
                tipoHistorico_Id: (
                  await getTiposHistorico(entity, { nome: "Ação CR" }, 1)
                )[0].id,
              },
            },
          },
        });
      } else if (acao_CrId !== undefined) {
        return prisma[tableAcoesCr].update({
          data: {
            excluido: true,
          },
          where: {
            id: acao_CrId,
          },
        });
      } else {
        return null;
      }
    };

    const getComunicado = async () => {
      if (emailAlerts) {
        return prisma[tableComunicados].upsert({
          where: {
            id: comunicado_Id === undefined ? "" : comunicado_Id,
          },
          update: {
            assunto: nome,
            remetenteComunicado: {
              connect: {
                id: emailRemetente,
              },
            },
            benefAssoc: {
              set: benefToConnectAcao.map(({ id }) => ({ id })),
            },
            conteudoEmail: JSON.stringify(conteudoEmail),
            excluido: false,
            historico: {
              create: {
                // categoria: "Comunicado",
                descricao:
                  "Atualização de comunicado em função da modificação do evento: " +
                  nome,
                beneficiario: {
                  connect: benefToConnectAcao.map(({ id }) => ({ id })),
                },
                tipoHistorico_Id: (
                  await getTiposHistorico(entity, { nome: "Comunicado" }, 1)
                )[0].id,
              },
            },
          },
          create: {
            assunto: nome,
            benefAssoc: {
              connect: benefToConnectAcao.map(({ id }) => ({ id })),
            },
            remetenteComunicado: {
              connect: {
                id: emailRemetente,
              },
            },
            conteudoEmail: JSON.stringify(conteudoEmail),
            historico: {
              create: {
                // categoria: "Comunicado",
                descricao:
                  "Criação de comunicado em função da modificação do evento: " +
                  nome,
                beneficiario: {
                  connect: benefToConnectAcao.map(({ id }) => ({ id })),
                },

                tipoHistorico_Id: (
                  await getTiposHistorico(entity, { nome: "Comunicado" }, 1)
                )[0].id,
              },
            },
          },
        });
      } else if (comunicado_Id !== undefined) {
        return prisma[tableComunicados].update({
          data: {
            excluido: true,
          },
          where: {
            id: comunicado_Id,
          },
        });
      } else {
        return null;
      }
    };

    const acaoCr = await getAcaoCr();
    const comunicado = await getComunicado();

    const query = await prisma[table].update({
      data: {
        nome,
        modalidade,
        data: DateTime.fromISO(data).toISO(),

        tipo_eventoId: tipo,
        local_EventoId: local || null,
        benefAssoc: {
          set: benefToConnectAcao.map(({ id }) => ({ id })),
        },
        acao_Cr: {
          set: acaoCr ? [{ id: acaoCr.id }] : [],
        },
        comunicado: {
          set: comunicado ? [{ id: comunicado.id }] : [],
        },
      },
      where: {
        id,
      },
    });
    return query;
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}

/**
 * Remove um Evento do BD.
 * @method deleteEvento
 * @memberof module:eventos
 * @param {String} entity a "entidade" ou "localização" do Projeto Primeiro Emprego
 * @param {Object} id o ID do Evento a ser excluído
 * @returns objeto contendo o resultado da query
 */
export async function deleteEvento(entity, id) {
  try {
    const table = `${entity}_Eventos`;
    const tableHistorico = `${entity}_Historico`;
    const query = await prisma[table].update({
      data: {
        excluido: true,
      },
      include: {
        benefAssoc: true,
      },
      where: {
        id,
      },
    });

    await prisma[tableHistorico].create({
      data: {
        descricao: `Exclusão do evento: ${query.nome}`,
        beneficiario: {
          connect: query.benefAssoc.map(({ id }) => ({ id })),
        },
        eventos: {
          connect: {
            id: query.id,
          },
        },
        tipoHistorico_Id: (
          await getTiposHistorico(entity, { nome: "Comunicado" }, 1)
        )[0].id,
      },
    });

    return query;
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}

/**
 * Fornece a listagem de locais de evento.
 * @method getLocaisEventos
 * @memberof module:eventos
 * @param {String} entity a localidade do Projeto (por exemplo, "ba" para Bahia)
 * @param {Object} filter Critério de pesquisa para detalhamento da query, onde os
 * critérios de pesquisa aceitos são os parâmetros possíveis no método queryComposer.
 * @param {Number} limit limita a quantidade de resultados na pesquisa. Por questões
 * de performance, em queries longas é sugerido usar limit como '1' quando se deseja
 * obter apenas 1 (ou o primeiro) resultado.
 * @returns {Object} Objeto contendo um Array de resultados. Ao usar 'limit',
 * selecionar o índice zero no objeto ([0]) para obter o valor adequado.
 */
export async function getLocaisEventos(entity, filter, limit) {
  try {
    const table = `${entity}_Locais_Eventos`;
    if (!_.isEmpty(filter)) {
      return await prisma[table].findMany({
        take: _.isUndefined(limit) ? undefined : parseInt(limit),
        orderBy: [
          {
            nome: "asc",
          },
        ],
        where: {
          ...queryComposer(filter),
        },
      });
    } else {
      return await prisma[table].findMany({
        take: _.isUndefined(limit) ? undefined : parseInt(limit),
        orderBy: [
          {
            nome: "asc",
          },
        ],
        where: {
          excluido: {
            equals: false,
          },
        },
      });
    }
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}

/**
 * Cria um Local de Evento
 * @method addLocalEvento
 * @memberof module:eventos
 * @param {String} entity a "entidade" ou "localização" do Projeto Primeiro Emprego
 * @param {Object} dadosEvento detalhes e informações adicionais sobre o local:
 *
 * nome - Nome do Local
 *
 * cep - CEP do local
 *
 * logradouro - identificação do logradouro (rua com número) do local do Evento
 *
 * complemento - dados adicionais do endereço do local do Evento
 *
 * bairro - bairro do endereço do local do Evento
 *
 * cidade - cidade do endereço do local do Evento
 *
 * uf - UF do local do Evento
 *
 * @returns {Object} Objeto contendo um Array de resultados.
 */
export function addLocalEvento(entity, dadosEvento) {
  try {
    const { nome, cep, logradouro, complemento, bairro, cidade, uf } =
      dadosEvento;
    const table = `${entity}_Locais_Eventos`;
    const query = prisma[table].upsert({
      create: {
        nome,
        cep,
        logradouro,
        complemento: complemento === "" ? null : complemento,
        bairro,
        cidade,
        uf,
      },
      update: {
        nome,
        cep,
        logradouro,
        complemento: complemento === "" ? null : complemento,
        bairro,
        cidade,
        uf,
        excluido: false,
      },
      where: {
        nome,
      },
    });
    return query;
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}

/**
 * Fornece a listagem de Tipos de Eventos.
 * @method getTiposEventos
 * @memberof module:eventos
 * @param {String} entity a localidade do Projeto (por exemplo, "ba" para Bahia)
 * @param {Object} filter Critério de pesquisa para detalhamento da query, onde os
 * critérios de pesquisa aceitos são os parâmetros possíveis no método queryComposer.
 * @param {Number} limit limita a quantidade de resultados na pesquisa. Por questões
 * de performance, em queries longas é sugerido usar limit como '1' quando se deseja
 * obter apenas 1 (ou o primeiro) resultado.
 * @returns {Object} Objeto contendo um Array de resultados. Ao usar 'limit',
 * selecionar o índice zero no objeto ([0]) para obter o valor adequado.
 */
export function getTiposEventos(entity, filter, limit) {
  try {
    const table = `${entity}_Tipos_Eventos`;
    if (!_.isEmpty(filter)) {
      return prisma[table].findMany({
        take: _.isUndefined(limit) ? undefined : parseInt(limit),
        where: {
          ...queryComposer(filter),
        },
        orderBy: [
          {
            nome: "asc",
          },
        ],
      });
    } else {
      return prisma[table].findMany({
        take: _.isUndefined(limit) ? undefined : parseInt(limit),
        where: {
          excluido: false,
        },
        orderBy: [
          {
            nome: "asc",
          },
        ],
      });
    }
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}

/**
 * Adiciona um Tipo de Evento ao BD.
 * @method addTipoEvento
 * @memberof module:eventos
 * @param {String} entity a "entidade" ou "localização" do Projeto Primeiro Emprego
 * @param {Object} nome o nome dado ao Tipo de Evento
 * @returns {Object} Objeto contendo um Array de resultados.
 */
export function addTipoEvento(entity, nome) {
  try {
    const table = `${entity}_Tipos_Eventos`;
    const query = prisma[table].upsert({
      create: {
        nome,
      },
      update: {
        nome,
      },
      where: {
        nome,
      },
    });
    return query;
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}

/**
 * Marca presença de um beneficiário a um determinado evento.
 * @method addPresencaBenefEvento
 * @memberof module:eventos
 * @param {String} entity a localidade do Projeto (por exemplo, "ba" para Bahia)
 * @param {Object} dadosEvento detalhes do evento.
 *
 * @returns {Object} Objeto contendo um Array de resultados.
 */
export async function addPresencaBenefEvento(entity, dadosEvento) {
  try {
    const table = `${entity}_Eventos_Lista_Presenca`;
    const { benefAssoc, eventoId } = dadosEvento;
    const benefMatriculas = benefAssoc.map((benef) => parseInt(benef.value));
    const benefCPFs = benefAssoc.map((benef) => benef.value.toString());

    const benefToConnectPresenca = await getBeneficiarios(entity, {
      cpf: benefCPFs,
      matriculaFlem: benefMatriculas,
      condition: "OR",
    });

    const query = await prisma[table].createMany({
      data: benefToConnectPresenca.map(({ id }) => ({
        benefAssocId: id,
      })),
    });
    return query;
  } catch (e) {
    throw exceptionHandler(e, 0);
  }
}
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      Made with ☕️ by <a href='https://github.com/frtechdev'>FR Technologies</a>
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"benefCheckBd","link":"<a href=\"global.html#benefCheckBd\">benefCheckBd</a>"},{"title":"benefValidate","link":"<a href=\"global.html#benefValidate\">benefValidate</a>"},{"title":"modifyContatoAcaoCr","link":"<a href=\"global.html#modifyContatoAcaoCr\">modifyContatoAcaoCr</a>"},{"title":"modifyEscRegMunicMonit","link":"<a href=\"global.html#modifyEscRegMunicMonit\">modifyEscRegMunicMonit</a>"},{"title":"normalizeString","link":"<a href=\"global.html#normalizeString\">normalizeString</a>"},{"title":"parseArrayToString","link":"<a href=\"global.html#parseArrayToString\">parseArrayToString</a>"},{"title":"parseArrayToStringEquals","link":"<a href=\"global.html#parseArrayToStringEquals\">parseArrayToStringEquals</a>"},{"title":"queryComposer","link":"<a href=\"global.html#queryComposer\">queryComposer</a>"},{"title":"replaceKeys","link":"<a href=\"global.html#replaceKeys\">replaceKeys</a>"}];
        var options = {}
          setupSearch(list, options)
      </script>
    

    
    <script type="text/javascript">
        function foo(){console.log('foo')}
    </script>
    

    
      <script src="scripts/resize.js"></script>
      <script type="text/javascript">
        var option = {"min":"300","max":"600"}
        setupResizeOptions(option)
      </script>
    

    
    <script type="text/javascript">
    var option = JSON.parse('{"options":{}}')
      document.addEventListener("DOMContentLoaded", function () {
        OverlayScrollbars(document.querySelectorAll('body'), option.option || {});
      });
    </script>
    


  </body>

</html>
